'''
ДП.3. Шифр Миши

Ограничение времени: 1.5 секунд
Ограничение памяти: 64.0 Мб
Ввод стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Маленький Миша прошёл умножение в школе и смог придумать свой шифр!
Суть шифра такова: чтобы расшифровать зашифрованное слово нужно просто раскрыть скобки! Вот базовая часть шифра: X(S), где X - число, а S - строка, которую нужно повторить X раз, чтобы расшифровать слово. Например, 3(ах) расшифровывается как ахахах. 
Также зашифрованные части могут быть вложенными, например, 2(3(ха)3(ля)) расшифровывается как хахахаляляляхахахаляляля (выполняем расшифровку по следующим правилам: сначала выполняем действия в скобках, а потом умножаем на число).
Миша уже и придумал практическую пользу шифра: зашифрованное сообщение может быть короче оригинального!
К сожалению, Миша так и не придумал хороший алгоритм для превращения слов в зашифрованные. Это и предстоит сделать вам! Миша хочет получить из обычного слова зашифрованное, причем минимальной длины!
Помогите Мише!

Описание входных данных
На вход подаётся строка с символами кириллицы. Длина строки не превышает 100 символов.

Описание выходных данных
В единственной строке данных выведите зашифрованную строку минимальной длины.

Формат ввода
аааааааааабабабввг

Формат вывода
9(а)3(аб)ввг

Примечания
Если слово можно зашифровать несколькими способами, например: ахахахахаха -> 5(ах)а или а5(ха), необходимо шифровать вторым способом (а5(ха)).
Кроме того, если длина зашифрованной подстроки больше или равна длине незашифрованной, то эту подстроку шифровать не нужно. Например: хихи шифровать не нужно, так как шифр (2(хи)) длиннее или для строки лалалахихилалала шифр будет следующим: 
3(ла)хихи3(ла) (обратите внимание, что подстрока хихи не была зашифрована).
'''

TABLE = {}

def create_table(string):
    for string_id in range(len(string)):
        left_id, right_id = 0, string_id
        while right_id != len(string):
            if left_id == right_id:
                TABLE[(left_id, right_id)] = string[left_id:right_id + 1]
            else:
                substring = string[left_id:right_id + 1]
                for divider in range(1, len(substring)):
                    if len(substring) % divider == 0 and substring[0:divider] * (
                            len(substring) // divider) == substring:
                        substring = f'{len(substring) // divider}({TABLE[(left_id, left_id + divider - 1)]})'
                        break
                if substring == string[left_id: right_id + 1]:
                    for middle_id in range(right_id - left_id - 1, -1, -1):
                        new_str = TABLE[(left_id, left_id + middle_id)] + TABLE[(left_id + middle_id + 1, right_id)]
                        if len(new_str) <= len(substring):
                            substring = new_str
                if len(substring) >= len(string[left_id: right_id + 1]):
                    TABLE[(left_id, right_id)] = string[left_id: right_id + 1]
                else:
                    TABLE[(left_id, right_id)] = substring
            right_id += 1
            left_id += 1


string = input()
if len(string) <= 4:
    print(string)
else:
    create_table(string)
    print(TABLE[(0, len(string) - 1)])
