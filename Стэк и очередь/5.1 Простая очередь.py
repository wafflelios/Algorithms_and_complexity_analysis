'''
5.1. Простая очередь

Ограничение времени: 0.5 секунд
Ограничение памяти: 16.0 Мб
Ввод стандартный ввод или input.txt
Вывод стандартный вывод или output.txt
Реализуйте структуру данных «очередь». Напишите программу, содержащую описание очереди и моделирующую работу очереди, реализовав все указанные здесь методы. 
Программа считывает последовательность команд и в зависимости от команды выполняет ту или иную операцию. 
После выполнения каждой команды программа должна вывести одну строчку. Возможные команды для программы:

1. push n Добавить в очередь число n (значение n задается после команды). Программа должна вывести «ok». (Сложность O(1))
2. pop Удалить из очереди первый элемент. Программа должна вывести его значение. (Сложность O(1))
3. front Программа должна вывести значение первого элемента, не удаляя его из очереди. (Сложность O(1))
4. size Программа должна вывести количество элементов в очереди. (Сложность O(1))
5. view Просмотреть всю очередь. Элементы очереди выводятся в порядке добавления, через запятую (пример: '1, 2, 3') (Сложность O(n))
6. clear Программа должна очистить очередь и вывести «ok». (Сложность O(1))
7. exit Программа должна вывести «bye» и завершить работу. (Сложность O(1))
Гарантируется, что набор входных команд удовлетворяет следующим требованиям: максимальное количество элементов в очереди в любой момент не превосходит 10 000,
все команды pop и front корректны, то есть при их исполнении в очереди содержится хотя бы один элемент.

Описание входных данных
Вводятся команды управления очередью, по одной на строке.

Описание выходных данных
Требуется вывести протокол работы с очередью, по одному сообщению на строке.

Формат ввода
size
push 1
size
push 2
size
push 3
size
exit

Формат вывода
0
ok
1
ok
2
ok
3
bye
'''

class Queue:
    def __init__(self):
        self.queue = []

    def push(self, num):
        self.queue.append(num)
        return 'ok'

    def pop(self):
        if not self.queue:
            return None
        else:
            return self.queue.pop(0)

    def front(self):
        if not self.queue:
            return None
        else:
            return self.queue[0]

    def size(self):
        return len(self.queue)

    def view(self):
        return ', '.join(self.queue)

    def clear(self):
        self.queue.clear()
        return 'ok'

    def exit(self):
        return 'bye'


command, queue, res = '', Queue(), ''
while command != 'exit':
    command = input()
    if 'push' in command:
        res += queue.push(command.split()[1]) + '\n'
    elif 'pop' in command:
        res += queue.pop() + '\n'
    elif 'front' in command:
        res += queue.front() + '\n'
    elif 'size' in command:
        res += str(queue.size()) + '\n'
    elif 'view' in command:
        res += queue.view() + '\n'
    elif 'clear' in command:
        res += queue.clear() + '\n'
res += queue.exit()
print(res)
